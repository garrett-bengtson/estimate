package edu.ndsu.cs.estimate.cayenne.persistent.auto;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.time.LocalDate;
import java.util.Date;

import org.apache.cayenne.BaseDataObject;
import org.apache.cayenne.exp.property.BaseProperty;
import org.apache.cayenne.exp.property.DateProperty;
import org.apache.cayenne.exp.property.EntityProperty;
import org.apache.cayenne.exp.property.NumericIdProperty;
import org.apache.cayenne.exp.property.NumericProperty;
import org.apache.cayenne.exp.property.PropertyFactory;
import org.apache.cayenne.exp.property.StringProperty;

import edu.ndsu.cs.estimate.cayenne.persistent.User;

/**
 * Class _Task was generated by Cayenne.
 * It is probably a good idea to avoid changing this class manually,
 * since it may be overwritten next time code is regenerated.
 * If you need to make any customizations, please use subclass.
 */
public abstract class _Task extends BaseDataObject {

    private static final long serialVersionUID = 1L;

    public static final NumericIdProperty<Integer> TASK_ID_PK_PROPERTY = PropertyFactory.createNumericId("TaskId", "Task", Integer.class);
    public static final String TASK_ID_PK_COLUMN = "TaskId";

    public static final DateProperty<LocalDate> ACTUAL_END_DATE = PropertyFactory.createDate("actualEndDate", LocalDate.class);
    public static final BaseProperty<Boolean> CANNOT_COMPLETE = PropertyFactory.createBase("cannotComplete", Boolean.class);
    public static final BaseProperty<Boolean> COMPLETED = PropertyFactory.createBase("completed", Boolean.class);
    public static final BaseProperty<Boolean> DROPPED = PropertyFactory.createBase("dropped", Boolean.class);
    public static final DateProperty<Date> EST_END_DATE = PropertyFactory.createDate("estEndDate", Date.class);
    public static final StringProperty<String> NAME = PropertyFactory.createString("name", String.class);
    public static final DateProperty<Date> START_DATE = PropertyFactory.createDate("startDate", Date.class);
    public static final NumericProperty<Integer> TIME_TAKEN = PropertyFactory.createNumeric("timeTaken", Integer.class);
    public static final BaseProperty<Boolean> WILL_NOT_COMPLETE = PropertyFactory.createBase("willNotComplete", Boolean.class);
    public static final EntityProperty<User> USER = PropertyFactory.createEntity("user", User.class);

    protected LocalDate actualEndDate;
    protected boolean cannotComplete;
    protected boolean completed;
    protected boolean dropped;
    protected Date estEndDate;
    protected String name;
    protected Date startDate;
    protected Integer timeTaken;
    protected boolean willNotComplete;

    protected Object user;

    public void setActualEndDate(LocalDate actualEndDate) {
        beforePropertyWrite("actualEndDate", this.actualEndDate, actualEndDate);
        this.actualEndDate = actualEndDate;
    }

    public LocalDate getActualEndDate() {
        beforePropertyRead("actualEndDate");
        return this.actualEndDate;
    }

    public void setCannotComplete(boolean cannotComplete) {
        beforePropertyWrite("cannotComplete", this.cannotComplete, cannotComplete);
        this.cannotComplete = cannotComplete;
    }

	public boolean isCannotComplete() {
        beforePropertyRead("cannotComplete");
        return this.cannotComplete;
    }

    public void setCompleted(boolean completed) {
        beforePropertyWrite("completed", this.completed, completed);
        this.completed = completed;
    }

	public boolean isCompleted() {
        beforePropertyRead("completed");
        return this.completed;
    }

    public void setDropped(boolean dropped) {
        beforePropertyWrite("dropped", this.dropped, dropped);
        this.dropped = dropped;
    }

	public boolean isDropped() {
        beforePropertyRead("dropped");
        return this.dropped;
    }

    public void setEstEndDate(Date estEndDate) {
        beforePropertyWrite("estEndDate", this.estEndDate, estEndDate);
        this.estEndDate = estEndDate;
    }

    public Date getEstEndDate() {
        beforePropertyRead("estEndDate");
        return this.estEndDate;
    }

    public void setName(String name) {
        beforePropertyWrite("name", this.name, name);
        this.name = name;
    }

    public String getName() {
        beforePropertyRead("name");
        return this.name;
    }

    public void setStartDate(Date startDate) {
        beforePropertyWrite("startDate", this.startDate, startDate);
        this.startDate = startDate;
    }

    public Date getStartDate() {
        beforePropertyRead("startDate");
        return this.startDate;
    }

    public void setTimeTaken(int timeTaken) {
        beforePropertyWrite("timeTaken", this.timeTaken, timeTaken);
        this.timeTaken = timeTaken;
    }

    public int getTimeTaken() {
        beforePropertyRead("timeTaken");
        if(this.timeTaken == null) {
            return 0;
        }
        return this.timeTaken;
    }

    public void setWillNotComplete(boolean willNotComplete) {
        beforePropertyWrite("willNotComplete", this.willNotComplete, willNotComplete);
        this.willNotComplete = willNotComplete;
    }

	public boolean isWillNotComplete() {
        beforePropertyRead("willNotComplete");
        return this.willNotComplete;
    }

    public void setUser(User user) {
        setToOneTarget("user", user, true);
    }

    public User getUser() {
        return (User)readProperty("user");
    }

    @Override
    public Object readPropertyDirectly(String propName) {
        if(propName == null) {
            throw new IllegalArgumentException();
        }

        switch(propName) {
            case "actualEndDate":
                return this.actualEndDate;
            case "cannotComplete":
                return this.cannotComplete;
            case "completed":
                return this.completed;
            case "dropped":
                return this.dropped;
            case "estEndDate":
                return this.estEndDate;
            case "name":
                return this.name;
            case "startDate":
                return this.startDate;
            case "timeTaken":
                return this.timeTaken;
            case "willNotComplete":
                return this.willNotComplete;
            case "user":
                return this.user;
            default:
                return super.readPropertyDirectly(propName);
        }
    }

    @Override
    public void writePropertyDirectly(String propName, Object val) {
        if(propName == null) {
            throw new IllegalArgumentException();
        }

        switch (propName) {
            case "actualEndDate":
                this.actualEndDate = (LocalDate)val;
                break;
            case "cannotComplete":
                this.cannotComplete = val == null ? false : (boolean)val;
                break;
            case "completed":
                this.completed = val == null ? false : (boolean)val;
                break;
            case "dropped":
                this.dropped = val == null ? false : (boolean)val;
                break;
            case "estEndDate":
                this.estEndDate = (Date)val;
                break;
            case "name":
                this.name = (String)val;
                break;
            case "startDate":
                this.startDate = (Date)val;
                break;
            case "timeTaken":
                this.timeTaken = (Integer)val;
                break;
            case "willNotComplete":
                this.willNotComplete = val == null ? false : (boolean)val;
                break;
            case "user":
                this.user = val;
                break;
            default:
                super.writePropertyDirectly(propName, val);
        }
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        writeSerialized(out);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        readSerialized(in);
    }

    @Override
    protected void writeState(ObjectOutputStream out) throws IOException {
        super.writeState(out);
        out.writeObject(this.actualEndDate);
        out.writeBoolean(this.cannotComplete);
        out.writeBoolean(this.completed);
        out.writeBoolean(this.dropped);
        out.writeObject(this.estEndDate);
        out.writeObject(this.name);
        out.writeObject(this.startDate);
        out.writeObject(this.timeTaken);
        out.writeBoolean(this.willNotComplete);
        out.writeObject(this.user);
    }

    @Override
    protected void readState(ObjectInputStream in) throws IOException, ClassNotFoundException {
        super.readState(in);
        this.actualEndDate = (LocalDate)in.readObject();
        this.cannotComplete = in.readBoolean();
        this.completed = in.readBoolean();
        this.dropped = in.readBoolean();
        this.estEndDate = (Date)in.readObject();
        this.name = (String)in.readObject();
        this.startDate = (Date)in.readObject();
        this.timeTaken = (Integer)in.readObject();
        this.willNotComplete = in.readBoolean();
        this.user = in.readObject();
    }

}
